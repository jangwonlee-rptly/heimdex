"""
The Main Entrypoint for the Heimdex FastAPI Service.

This module is the central hub of the API service. It is responsible for:
1.  **Initializing the FastAPI Application**: Creating the main `app` instance.
2.  **Registering Routers**: Including all the different API route modules (like
    the one for jobs) into the main application.
3.  **Setting Up Middleware**: Attaching middleware for cross-cutting concerns,
    such as logging every incoming HTTP request.
4.  **Managing Application Lifecycle**: Defining logic that runs on application
    startup (e.g., loading configuration, logging a start message) and shutdown.
5.  **Defining Core Health Endpoints**: Providing `/healthz` (liveness) and
    `/readyz` (readiness) endpoints, which are essential for running the service
    in a container orchestration system like Kubernetes.
"""

from __future__ import annotations

import os
import time
from collections.abc import Awaitable, Callable
from datetime import UTC, datetime

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse, Response

from . import SERVICE_NAME, __version__
from .jobs import router as jobs_router
from .logger import log_event

# --- Global Service Metadata ---
_ENV = os.getenv("HEIMDEX_ENV", "local")
_STARTED_AT = datetime.now(UTC)
_STARTED_AT_ISO = _STARTED_AT.isoformat()

# --- FastAPI Application Initialization ---
app = FastAPI(
    title="Heimdex API",
    version=__version__,
    # These parameters are used to generate the OpenAPI documentation (e.g., at /docs).
)

# Include the router from the `jobs` module. This is a key part of FastAPI's
# modular design, allowing us to organize endpoints into different files.
app.include_router(jobs_router)


@app.on_event("startup")
async def on_startup() -> None:
    """
    Handles application startup logic.

    This function is a FastAPI event handler that is executed once when the
    server process starts. It is the ideal place for initialization tasks that
    should happen before the server begins accepting requests. Here, we use it
    to log a structured message indicating that the service has started, along
    with its configuration. This is invaluable for debugging deployments.
    """
    from heimdex_common.config import get_config

    from .outbox_dispatcher import start_dispatcher_thread

    config = get_config()
    log_event(
        "INFO",
        "service_startup",
        details={
            "env": _ENV,
            "started_at": _STARTED_AT_ISO,
            "config_summary": config.log_summary(redact_secrets=True),
        },
    )

    # Start the outbox dispatcher background thread
    start_dispatcher_thread()
    log_event("INFO", "outbox_dispatcher_started")


@app.on_event("shutdown")
async def on_shutdown() -> None:
    """
    Handles application shutdown logic.

    This event handler is executed just before the server stops. It's used here
    to log a clean shutdown message. In more complex applications, this is where
    you would gracefully close database connections, flush buffers, or perform
    other cleanup tasks.
    """
    log_event("INFO", "service_shutdown")


@app.middleware("http")
async def request_logger(
    request: Request, call_next: Callable[[Request], Awaitable[Response]]
) -> Response:
    """
    A middleware that logs every incoming HTTP request and its response.

    Middleware in FastAPI is a powerful way to process every request before it
    hits the endpoint and every response before it's sent to the client. This
    function implements a logger that provides visibility into the API's traffic,
    capturing key information like the request path, method, response status code,
    and, crucially, the processing duration. This is a cornerstone of observability.

    Args:
        request: The incoming HTTP request.
        call_next: The function that passes the request to the next handler.

    Returns:
        The HTTP response generated by the endpoint.
    """
    start_time = time.perf_counter()
    response = await call_next(request)
    duration_ms = (time.perf_counter() - start_time) * 1000
    log_event(
        "INFO",
        "http_request",
        method=request.method,
        path=request.url.path,
        status_code=response.status_code,
        duration_ms=round(duration_ms, 2),
    )
    return response


@app.get("/healthz", tags=["health"], response_class=JSONResponse)
async def healthz() -> JSONResponse:
    """
    Provides a basic liveness probe endpoint.

    In container orchestration systems like Kubernetes, a liveness probe is used
    to determine if a container's main process is running and responsive. If this
    endpoint fails to respond, the orchestrator will assume the container is
    "dead" and restart it.

    Therefore, this endpoint should be very simple and fast. It does **not** check
    external dependencies. It simply confirms that the HTTP server is up.

    Returns:
        A JSON response indicating the service is alive ("ok": True).
    """
    payload = {
        "ok": True,
        "service": SERVICE_NAME,
        "version": __version__,
        "env": _ENV,
        "started_at": _STARTED_AT_ISO,
    }
    return JSONResponse(content=payload)


@app.get("/readyz", tags=["health"], response_class=JSONResponse)
async def readyz() -> JSONResponse:
    """
        Provides a comprehensive readiness probe endpoint.

        A readiness probe is used to determine if a container is ready to start
        accepting traffic. This is a more in-depth check than the liveness probe. It
        verifies the health of all critical downstream dependencies (like the database
        and Redis) using the profile-aware `check_readiness` function from the common
        probes module.

        If any *enabled* dependency is unhealthy, this endpoint will return an
        HTTP 503 Service Unavailable status. This signals to the orchestrator (or
        load balancer) that it should not route traffic to this instance of the
    agb service until the dependencies are healthy again.

        Returns:
            A detailed JSON response on the status of all dependencies. The HTTP
            status code will be 200 if ready, or 503 if not.
    """
    from heimdex_common.probes import check_readiness

    result = check_readiness(service=SERVICE_NAME, version=__version__)
    status_code = 200 if result["ready"] else 503
    return JSONResponse(content=result, status_code=status_code)
