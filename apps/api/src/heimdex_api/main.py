"""Entrypoint for the Heimdex API service."""

from __future__ import annotations

import os
import time
from collections.abc import Awaitable, Callable
from datetime import UTC, datetime

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse, Response

from . import SERVICE_NAME, __version__
from .jobs import router as jobs_router
from .logger import log_event

_ENV = os.getenv("HEIMDEX_ENV", "local")
_STARTED_AT = datetime.now(UTC)
_STARTED_AT_ISO = _STARTED_AT.isoformat()

app = FastAPI(title="Heimdex API", version=__version__)
app.include_router(jobs_router)


@app.on_event("startup")
async def on_startup() -> None:
    """
    Handle application startup events.

    This function is executed when the FastAPI application starts. It logs a startup
    message with redacted configuration, and prepares the database connection pool.
    Database schema migrations should be run separately via Alembic.
    """
    from heimdex_common.config import get_config

    config = get_config()
    log_event(
        "INFO",
        "starting",
        env=_ENV,
        started_at=_STARTED_AT_ISO,
        config=config.log_summary(redact_secrets=True),
    )


@app.on_event("shutdown")
async def on_shutdown() -> None:
    """
    Handle application shutdown events.

    This function is executed when the FastAPI application shuts down. It logs a
    simple "stopping" message to indicate that the service is terminating gracefully.
    """
    log_event("INFO", "stopping")


@app.middleware("http")
async def request_logger(
    request: Request, call_next: Callable[[Request], Awaitable[Response]]
) -> Response:
    """
    Log incoming HTTP requests.

    This middleware intercepts every incoming request, logs its method, path, and
    the time taken to process it.

    Args:
        request: The incoming FastAPI request object.
        call_next: A function that passes the request to the next middleware or
                   endpoint.

    Returns:
        The response generated by the endpoint.
    """
    start = time.perf_counter()
    response = await call_next(request)
    duration_ms = (time.perf_counter() - start) * 1000
    log_event(
        "INFO",
        "request",
        method=request.method,
        path=request.url.path,
        status_code=response.status_code,
        duration_ms=round(duration_ms, 2),
    )
    return response


@app.get("/healthz", response_class=JSONResponse)
async def healthz() -> JSONResponse:
    """
    Perform a basic health check.

    This endpoint returns a JSON response with the service's status, version,
    environment, and start time, confirming that the API process is running.
    This does NOT check dependencies - use /readyz for that.

    Returns:
        A JSON response containing the health check information.
    """
    payload = {
        "ok": True,
        "service": SERVICE_NAME,
        "version": __version__,
        "env": _ENV,
        "started_at": _STARTED_AT_ISO,
    }
    return JSONResponse(content=payload)


@app.get("/readyz", response_class=JSONResponse)
async def readyz() -> JSONResponse:
    """
    Perform a profile-aware readiness check with dependency probes.

    This endpoint probes only enabled dependencies (configured via ENABLE_* flags)
    and returns their status with timing information. The service is considered ready
    only if all enabled dependencies are reachable.

    Disabled dependencies (e.g., Qdrant, GCS) are skipped and don't affect readiness.

    Returns:
        A JSON response with uniform structure:
        - service, env, version, ready, summary
        - deps: per-dependency results with enabled/skipped/ok/latency_ms/attempts/reason
        Returns HTTP 503 if any enabled dependency is down.
    """
    from heimdex_common.probes import check_readiness

    result = check_readiness(service=SERVICE_NAME, version=__version__)
    status_code = 200 if result["ready"] else 503
    return JSONResponse(content=result, status_code=status_code)
